
/*
 * This file was automatically generated by sdbus-c++-xml2cpp; DO NOT EDIT!
 */

#ifndef _sdbuscpp_freedesktop_flatpak_client_glue_proxy_H_
#define _sdbuscpp_freedesktop_flatpak_client_glue_proxy_H_

#include <sdbus-c++/sdbus-c++.h>
#include <string>
#include <tuple>


namespace org::freedesktop::Flatpak {
    class SessionHelper_proxy {
    public:
        static constexpr auto INTERFACE_NAME = "org.freedesktop.Flatpak.SessionHelper";

        SessionHelper_proxy(const SessionHelper_proxy &) = delete;

        SessionHelper_proxy &operator=(const SessionHelper_proxy &) = delete;

        SessionHelper_proxy(SessionHelper_proxy &&) = delete;

        SessionHelper_proxy &operator=(SessionHelper_proxy &&) = delete;

    protected:
        explicit SessionHelper_proxy(sdbus::IProxy &proxy)
            : m_proxy(proxy) {
        }

        ~SessionHelper_proxy() = default;

        void registerProxy() {
        }

    public:
        [[nodiscard]] std::map<std::string, sdbus::Variant> RequestSession() const {
            std::map<std::string, sdbus::Variant> result;
            m_proxy.callMethod("RequestSession").onInterface(INTERFACE_NAME).storeResultsTo(result);
            return result;
        }

    public:
        [[nodiscard]] uint32_t version() const {
            return m_proxy.getProperty("version").onInterface(INTERFACE_NAME).get<uint32_t>();
        }

    private:
        sdbus::IProxy &m_proxy;
    };
} // namespaces


namespace org::freedesktop::Flatpak {
    class Development_proxy {
    public:
        static constexpr auto INTERFACE_NAME = "org.freedesktop.Flatpak.Development";

        Development_proxy(const Development_proxy &) = delete;

        Development_proxy &operator=(const Development_proxy &) = delete;

        Development_proxy(Development_proxy &&) = delete;

        Development_proxy &operator=(Development_proxy &&) = delete;

    protected:
        explicit Development_proxy(sdbus::IProxy &proxy)
            : m_proxy(proxy) {
        }

        ~Development_proxy() = default;

        void registerProxy() {
            m_proxy.uponSignal("HostCommandExited").onInterface(INTERFACE_NAME).call(
                [this](const uint32_t &pid, const uint32_t &exit_status) {
                    this->onHostCommandExited(pid, exit_status);
                });
        }

        virtual void onHostCommandExited(const uint32_t &pid, const uint32_t &exit_status) = 0;

    public:
        [[nodiscard]] uint32_t HostCommand(const std::vector<uint8_t> &cwd_path,
                                           const std::vector<std::vector<uint8_t> > &argv,
                                           const std::map<uint32_t, sdbus::UnixFd> &fds,
                                           const std::map<std::string, std::string> &envs,
                                           const uint32_t &flags) const {
            uint32_t result;
            m_proxy.callMethod("HostCommand").onInterface(INTERFACE_NAME).withArguments(
                cwd_path, argv, fds, envs, flags).storeResultsTo(result);
            return result;
        }

        void HostCommandSignal(const uint32_t &pid, const uint32_t &signal, const bool &to_process_group) const {
            m_proxy.callMethod("HostCommandSignal").onInterface(INTERFACE_NAME).withArguments(
                pid, signal, to_process_group);
        }

    public:
        [[nodiscard]] uint32_t version() const {
            return m_proxy.getProperty("version").onInterface(INTERFACE_NAME).get<uint32_t>();
        }

    private:
        sdbus::IProxy &m_proxy;
    };
}

// namespaces

namespace org::freedesktop::Flatpak {
    class SystemHelper_proxy {
    public:
        static constexpr auto INTERFACE_NAME = "org.freedesktop.Flatpak.SystemHelper";

        SystemHelper_proxy(const SystemHelper_proxy &) = delete;

        SystemHelper_proxy &operator=(const SystemHelper_proxy &) = delete;

        SystemHelper_proxy(SystemHelper_proxy &&) = delete;

        SystemHelper_proxy &operator=(SystemHelper_proxy &&) = delete;

    protected:
        explicit SystemHelper_proxy(sdbus::IProxy &proxy)
            : m_proxy(proxy) {
        }

        ~SystemHelper_proxy() = default;

        void registerProxy() {
        }

    public:
        void Deploy(const std::vector<uint8_t> &repo_path, const uint32_t &flags, const std::string &ref,
                    const std::string &origin, const std::vector<std::string> &subpaths,
                    const std::vector<std::string> &previous_ids, const std::string &installation) const {
            m_proxy.callMethod("Deploy").onInterface(INTERFACE_NAME).withArguments(
                repo_path, flags, ref, origin, subpaths, previous_ids, installation);
        }

        void DeployAppstream(const std::vector<uint8_t> &repo_path, const uint32_t &flags, const std::string &origin,
                             const std::string &arch, const std::string &installation) const {
            m_proxy.callMethod("DeployAppstream").onInterface(INTERFACE_NAME).withArguments(
                repo_path, flags, origin, arch, installation);
        }

        void Uninstall(const uint32_t &flags, const std::string &ref, const std::string &installation) const {
            m_proxy.callMethod("Uninstall").onInterface(INTERFACE_NAME).withArguments(flags, ref, installation);
        }

        [[nodiscard]] std::string InstallBundle(const std::vector<uint8_t> &bundle_path, const uint32_t &flags,
                                                const std::string &remote, const std::string &installation) const {
            std::string result;
            m_proxy.callMethod("InstallBundle").onInterface(INTERFACE_NAME).withArguments(
                bundle_path, flags, remote, installation).storeResultsTo(result);
            return result;
        }

        void ConfigureRemote(const uint32_t &flags, const std::string &remote, const std::string &config,
                             const std::vector<uint8_t> &gpg_key, const std::string &installation) const {
            m_proxy.callMethod("ConfigureRemote").onInterface(INTERFACE_NAME).withArguments(
                flags, remote, config, gpg_key, installation);
        }

        void Configure(const uint32_t &flags, const std::string &key, const std::string &value,
                       const std::string &installation) const {
            m_proxy.callMethod("Configure").onInterface(INTERFACE_NAME).withArguments(flags, key, value, installation);
        }

        void UpdateRemote(const uint32_t &flags, const std::string &remote, const std::string &installation,
                          const std::vector<uint8_t> &summary_path,
                          const std::vector<uint8_t> &summary_sig_path) const {
            m_proxy.callMethod("UpdateRemote").onInterface(INTERFACE_NAME).withArguments(
                flags, remote, installation, summary_path, summary_sig_path);
        }

        void RemoveLocalRef(const uint32_t &flags, const std::string &remote, const std::string &ref,
                            const std::string &installation) const {
            m_proxy.callMethod("RemoveLocalRef").onInterface(INTERFACE_NAME).withArguments(
                flags, remote, ref, installation);
        }

        void PruneLocalRepo(const uint32_t &flags, const std::string &installation) const {
            m_proxy.callMethod("PruneLocalRepo").onInterface(INTERFACE_NAME).withArguments(flags, installation);
        }

        void RunTriggers(const uint32_t &flags, const std::string &installation) const {
            m_proxy.callMethod("RunTriggers").onInterface(INTERFACE_NAME).withArguments(flags, installation);
        }

        void EnsureRepo(const uint32_t &flags, const std::string &installation) const {
            m_proxy.callMethod("EnsureRepo").onInterface(INTERFACE_NAME).withArguments(flags, installation);
        }

        void UpdateSummary(const uint32_t &flags, const std::string &installation) const {
            m_proxy.callMethod("UpdateSummary").onInterface(INTERFACE_NAME).withArguments(flags, installation);
        }

        void GenerateOciSummary(const uint32_t &flags, const std::string &origin,
                                const std::string &installation) const {
            m_proxy.callMethod("GenerateOciSummary").onInterface(INTERFACE_NAME).withArguments(
                flags, origin, installation);
        }

        void CancelPull(const uint32_t &flags, const std::string &installation, const std::string &src_dir) const {
            m_proxy.callMethod("CancelPull").onInterface(INTERFACE_NAME).withArguments(flags, installation, src_dir);
        }

        [[nodiscard]] std::tuple<sdbus::UnixFd, std::string> GetRevokefsFd(
            const uint32_t &flags, const std::string &installation) const {
            std::tuple<sdbus::UnixFd, std::string> result;
            m_proxy.callMethod("GetRevokefsFd").onInterface(INTERFACE_NAME).withArguments(flags, installation).
                    storeResultsTo(result);
            return result;
        }

    public:
        [[nodiscard]] uint32_t version() const {
            return m_proxy.getProperty("version").onInterface(INTERFACE_NAME).get<uint32_t>();
        }

    private:
        sdbus::IProxy &m_proxy;
    };
}

#endif
